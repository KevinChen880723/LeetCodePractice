# Note 

這題問我們說一個序列裡面，最長的遞增數列可能到多長，這過程中可以穿插其他數字。例如輸入如果是`[0, 1, 6, 2, 3, 8]`的話，那最長的長度會是由數列`[0, 1, 2, 3, 8]`構成的`5`。

我們不需要知道具體的數列是由哪些數字組成，只需要知道數列有多長就好。

## O(n^2)解法

只要新加入的數字只要比當前數列的最大值還大，就可以直接加入該數列中。然後因為題目要求嚴格遞增數列，因此有效數列的最後一個數字一定是其最大值。因此在得到新的數字時，我們只需要跟各個數列的最後一個數值比大小就好，如果比他大，則新的數列就有辦法組成一個長度為`list.size()+1`的數列。

不過因為存在許多組數列，如果一個一個比較將會花很多時間，因此需要想個辦法來減少運算時間。回想一下數列的特性，我們可以知道一個有效數列的最右邊一定會是其最大值，而我們又只需要跟數列的最大值比大小。因此我們可以使用DP的方式，開一個陣列來記錄「以各個數字為結尾的最長數列」。如此一來，當我們看到第`n`個數字時，就只需要去看`n-1`組數列，找出他可以加入的數列中，最長的數列。假如最長的數列的長度為`k`，則新的數字就有辦法加入一個長度為`k+1`的數列，這實再回去更新dp陣列就好。當我們看完所有數字，也記錄好DP陣列後，就只需要遍歷一次此陣列，就可以知道最長數列有多長。

由於我們要看`n`個數字，而每個數字都要去看`n-1`個當前數列，因此時間複雜度為`O(n^2)`。

```cpp
class Solution {
public:
    int lengthOfLIS(vector<int>& nums) {
        vector<int> dp(nums.size(), 1);
        for (int y = 1; y < nums.size(); y++) {
            int largest = 1;
            for (int x = 0; x < y; x++) {
                if (nums[y] > nums[x]) {
                    largest = max(largest, dp[x]+1);
                }
            }
            dp[y] = largest;
        }
        int largest = -10000000;
        for (int i = 0; i < dp.size(); i++) {
            largest = max(largest, dp[i]);
        }
        return largest;
    }
};
```

