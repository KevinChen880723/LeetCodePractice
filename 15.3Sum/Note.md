# Note

## Baseline Solution

這個題目希望我們在一個數列中找出各組可以組出0的組合，其中各個組合都包含三個數字，而且這三個數字不能是重複index的數字。我的想法跟twoSum差不多，使用兩層回圈來看所有數字，並將這兩個數字相加，剩下要做的就只剩下尋找第三個數字。由於目標是希望三個數字加起來為0，因此可以使用Hash map的方式去搜尋第三個數字。

完成了以上的步驟之後，找出來的結果可楞包含重複的組合，為了解決這個問題，我再使用另一個回圈來把重複的資料拿掉。由於這個部分的時間複雜度也是O(n^2)，因此雖然會影響運算時間，但不會影響時間複雜度。

<img width="777" alt="圖片" src="https://user-images.githubusercontent.com/55487740/153605441-21571f5c-8d67-46e0-a178-dbd6b15502bc.png">

## Using Two Pointers Version

在一開始先排序數列，之後先固定某一個數字之後去找其他兩個數字，找其他兩個數字的具體方法為：由於已經做了數列的排序，因此可以從剩下範圍的左右兩邊開始搜尋，每次都去看三個數字的和，如果相加的結果大於`0`，那麼就將右邊的指標往左邊移動，這樣就可以讓數字和變小；反之，如果相加的結果小於`0`，那麼就將左邊的指標往右移動，這樣就可以讓數字和變大；假如相加和為`0`，就將這組結果加入輸出的`vector`。

> `j`之所以是從`i`的右邊一個位置開始是因為為了不要重複選到同一組數組。

<img width="777" alt="圖片" src="https://user-images.githubusercontent.com/55487740/153605576-912a2a1b-b3c8-4660-8fa9-c44274765d3f.png">

<img width="777" alt="圖片" src="https://user-images.githubusercontent.com/55487740/153605152-c27e7c09-dedd-489d-a73b-b2b67a3d8465.png">
