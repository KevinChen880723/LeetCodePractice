# Note

## 1. My Failed Method

一開始我在看這題的時候想說我應該可以先去找出所有數字和為`target`的兩個數字，之後再用相同的函數以遞迴的方式去搜尋這兩個數字還可以用哪兩個數字組成，並且在找到那兩個數字的子組合之後，再將這些子組合排列出來，最後再將這些可能的組合加到`result`中。假如過程中找不到總和為`target`的兩個數字，就依序嘗試讓`target`減去最大的數字之後再繼續找兩個數字。不過這個方法有個問題：有可能我找到兩個數字和，但找不到三個數字和的結果，原因是使用這個方法能找到的三個數字一定是由兩個數字往下找的。例如出現`candidates={5, 6, 7, 9, 13}`，`target=20`的情況，就只能找出`{{7, 13}, {6, 7, 7}}`的解，而找不到`{{5, 5, 5, 5}, {5, 6, 9}}`。

## 2. Backtracking Solution

這題我的方法失敗後我就去看人家都怎麼做，我發現大部分的人都使用Backtracking的方式來完成這題，因此以下筆記將會先大致講解什麼是「回溯法」。

### Backtracking（回溯法）

他遍歷所有數字的方式跟DFS一樣，跟DFS只差在：DFS是用來走過所有的節點，最後輸出的結果一定會包含所有節點中的數值；但回溯法通常是用來做窮舉符合條件的集合，跟DFS的差別在於，這種方法中包含了「回溯」的概念，也就是如果加入新的數值會使條件不成立，則回到上一個狀態來繼續尋找下一種可能性，這個過程就叫做Backtracking，使用剪枝的技巧來提早結束後續不符合條件的搜尋。

### 使用回溯法完成這題

這題題目要我們找出所有總和為`target`的集合。這題可以採用回溯法的方式，一個一個地將`candidates`中的數字加到集合中。我們知道使用回溯法時，會希望找到一些方法來避免窮舉的發生。在這題中，我們可以在一開始先將數列做排序，當我們發現加入新的數字會超過`target`，則後續的其他數字也都不需要檢查了，這是其中一種剪枝。

不過這題要如何做到不要包含重複的集合呢？我覺得可以先想看看重複的集合會發生在什麼情況。如果集合重複，就代表我們只是將一個數列的順序打亂，但他們還是屬於同一個集合。不過這種情況只有未排序的數列會發生，因為這種時候相同數字可能出現在任意位置，就有可能發生像這樣的情況：
- `candidates`: `[1, 2, 1, 3]`
- `target`: `4`
- 最後選到：`{1, 1, 2}`、`{1, 2, 1}`或者`{2, 1, 1}`

他的運作邏輯為：到每個點都去看要不要把當前候選數列`candidates`的第一個數值加入當前已選擇的集合中，這樣就可以做到重複選擇某個數字的效果。而對於不選擇將第一個數值加入目標集合的那一個遞迴路徑，後續就不需要再繼續考慮是否加入該數值，可以將該數值從候選數列拿掉（對應到程式就是把`startIdx`加一），這樣才能避免重複選擇相同集合，把考慮第一個數值的可能集合交給那一列的遞迴路徑負責。

他跟DFS很像，我們可以把`candidates=[2, 3, 6, 7]`、`target=7`的運作過程表示為下圖：我們在Backtrack到之前的狀態之後，就不要再考慮之前看過的數值，因此最左邊那排找完回到`{2, 2}`後，他會接著去確認`{2, 2, 3}`是否符合條件，也就是不會再考慮所有包含`{2, 2, 2}`的集合了。

<img width="1440" alt="圖片" src="https://user-images.githubusercontent.com/55487740/154810014-99de0a6a-7111-48f8-9da0-0c57a0287260.png">

![](https://i.imgur.com/VakRWMz.png)
