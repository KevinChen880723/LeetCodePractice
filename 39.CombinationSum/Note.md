# Note

## 1. My Failed Method

一開始我在看這題的時候想說我應該可以先去找出所有數字和為`target`的兩個數字，之後再用相同的函數以遞迴的方式去搜尋這兩個數字還可以用哪兩個數字組成，並且在找到那兩個數字的子組合之後，再將這些子組合排列出來，最後再將這些可能的組合加到`result`中。假如過程中找不到總和為`target`的兩個數字，就依序嘗試讓`target`減去最大的數字之後再繼續找兩個數字。不過這個方法有個問題：有可能我找到兩個數字和，但找不到三個數字和的結果，原因是使用這個方法能找到的三個數字一定是由兩個數字往下找的。例如出現`candidates={5, 6, 7, 9, 13}`，`target=20`的情況，就只能找出`{{7, 13}, {6, 7, 7}}`的解，而找不到`{{5, 5, 5, 5}, {5, 6, 9}}`。

## 2. Backtracking Solution

這題我的方法失敗後我就去看人家都怎麼做，我發現大部分的人都使用Backtracking的方式來完成這題，因此以下筆記將會先大致講解什麼是「回溯法」。

### Backtracking（回溯法）

他的概念跟DFS很像，只是因為DFS是用來走過所有的節點，最後輸出的結果一定會包含所有節點中的數值；但回溯法通常是用來做窮舉，為了做到窮舉，這種方法中包含了「回溯」的概念，也就是回到上一個狀態來繼續尋找下一種可能性。但因為窮舉非常地耗費時間，因此使用回溯法時，可以使用剪枝的技巧來提早結束後續不符合條件的搜尋。

### 使用回溯法完成這題

這題題目要我們找出所有總和為`target`的集合。這時候就可以採用回溯法的方式，一個一個地將`candidates`中的數字加到集合中，並且隨時檢查當前相加和是否大於`target`，假如大於的話就沒必要繼續往後檢查了，這就是一種使用剪枝回溯法的例子。

不過這題要如何做到不要包含重複的集合呢？如同前面的介紹可以知道回溯法的原理跟DFS很像，只是他多了一個回溯的過程。由於他跟DFS很像，因此我們可以把`candidates=[2, 3, 6, 7]`、`target=7`的運作過程表示為下圖：我們在Backtrack到之前的狀態之後，就不要再考慮之前看過的數值，因此最左邊那排找完回到`{2, 2}`後，他會接著去確認`{2, 2, 3}`是否符合條件，也就是不會再考慮所有包含`{2, 2, 2}`的集合了。

<img width="1440" alt="圖片" src="https://user-images.githubusercontent.com/55487740/154810014-99de0a6a-7111-48f8-9da0-0c57a0287260.png">

![](https://i.imgur.com/VakRWMz.png)
