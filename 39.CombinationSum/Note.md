# Note

## My Failed Method

一開始我在看這題的時候想說我應該可以先去找出所有數字和為`target`的兩個數字，之後再用相同的函數以遞迴的方式去搜尋這兩個數字還可以用哪兩個數字組成，並且在找到那兩個數字的子組合之後，再將這些子組合排列出來，最後再將這些可能的組合加到`result`中。假如過程中找不到總和為`target`的兩個數字，就依序嘗試讓`target`減去最大的數字之後再繼續找兩個數字。不過這個方法有個問題：有可能我找到兩個數字和，但找不到三個數字和的結果，原因是使用這個方法能找到的三個數字一定是由兩個數字往下找的。例如出現`candidates={5, 6, 7, 9, 13}`，`target=20`的情況，就只能找出`{{7, 13}, {6, 7, 7}}`的解，而找不到`{{5, 5, 5, 5}, {5, 6, 9}}`。

## Backtracking Solution

這題我

### Backtracking（回溯法）

他的概念跟DFS很像，只是因為DFS是用來走過所有的節點，最後輸出的結果一定會包含所有節點中的數值；但回溯法通常是用來做窮舉，為了做到窮舉，這種方法中包含了「回溯」的概念，也就是回到上一個狀態來繼續尋找下一種可能性。但因為窮舉非常地耗費時間，因此使用回溯法時，可以使用剪枝的技巧來提早結束後續不符合條件的搜尋。

以LeetCode第39題「Combination Sum」來說，題目要我們找出所有總和為`target`的集合。這時候就可以採用回溯法的方式，一個一個地將`candidates`中的數字加到集合中，並且隨時檢查當前相加和是否大於`target`，假如大於的話就沒必要繼續往後檢查了，這就是一種使用剪枝回溯法的例子。不過這題要如何做到不要包含重複的集合呢？

![](https://i.imgur.com/VakRWMz.png)
