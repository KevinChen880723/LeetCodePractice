# Note

## Baseline Solution

這個解法會對應到LeetCode中的暴力解，作法為：一開始先使用`unordered_map`來記錄所有`wordDict`中的變數，這樣我們就可以讓我們在`O(1)`的時間內找到`wordDict`中是否存在我們要找的字串。另外，我們還使用另外一個函數來作為執行遞迴功能，該函數中會從頭開始一個一個將字元加入子字串中，之後去檢查該子字串是否出現在`wordDict`中，如果有的話就遞迴呼叫相同函數來檢查剩下的子字串是否歐虧；反之，如果沒有的話，就再繼續檢查；若已經將所有字元加入子字串中還找不到，就代表這個子字串不歐虧，因此回傳`false`。

使用這個方法在LeetCode中會跑不過，運算時間過長。他的時間複雜度在最差的情況為`O(2^n)`，原因是假如我們每次在將新的字元加進來子字串時`wordDict`中都有一個符合的字串，他就會去遞迴搜尋剩下的子字串是否歐虧。一開始我一直想不到為什麼時間複雜度是`O(2^n)`而不是`O(n!)`，我會覺得是`O(n!)`的原因是想說對於一個長度為`n`的字串，他在遞迴中的第一層時一共需要呼叫`n-1`次第二層的遞迴函數，然後第二層的遞迴函數則需要呼叫`n-1`次第三層的遞迴函數......。不過其實第二層的遞迴函數並不是每個都會呼叫`n-2`次第三層的遞迴函數，原因是：這`n-1`個第二層的遞迴函數對應到的子字串長度其實不同，只有一個人的長度是`n-1`，最短的甚至為`1`。基於這個原因我們可以了解到第一層一共會呼叫`n-1`個第二層的遞迴函數，所有第二層的遞迴函數「一共」會呼叫`(n-3)+(n-4)+...+1`個第三層的遞迴函數（如果只看當前三層就可以知道總次數不會是`n*(n-1)*(n-2)`）。下圖為網路上別人畫的圖，圖片的看法為：線上的字代表該子字串有出現在`wordDict`中，而每個節點代表呼叫遞迴函數來檢查剩下的子字串。透過這張圖可以清楚地了解一個長的為4的字串一共會呼叫`8`次遞迴函數（灰色部分會被返回，不會被走到），因此可以總結出一共需要`2^(n-1)`的時間來完成此程式，時間複雜度為`2^n`。

![圖片](https://user-images.githubusercontent.com/55487740/158069856-18153158-c159-413a-ba9b-fb823de76124.png)

## Recursion with memoization

原本的作法運作起來非常慢的一個原因是他會重複檢查相同的子字串，其中每一次檢查都需要花很多時間。為了改善這個問題，其實可以使用之前用過的**Recursion with memoization**方法，將已經檢查過的資料以一個變數來記憶，這題因為丟入遞迴函數的是字串變數，回傳的是布林變數，因此記憶體變數會採用以字串作為key、以布林作為value的`unordered_map`。

使用這個方法的時間複雜度為`O(n^3)`，原因是遞迴數中一共有`n^2`個節點，其中每個節點都有使用時間複雜度為`O(n)`的函數`substr()`。

<img width="725" alt="圖片" src="https://user-images.githubusercontent.com/55487740/158025377-5f3de77e-c8de-4795-b2c9-14f64c938c4e.png">

## DP Solution

DP就是使用已經解決的小問題來解決大問題，這題其實也可以拆解成這樣的作法。從最短的子字串到更大的子字串開始慢慢檢查，檢查長度為`n`的子字串時，可以重複使用長度為`1`到長度為`n-1`的結果，假如這些子字串符合條件就去檢查剩下長度為`n-1`到長度為`1`的子字串，假如剩下的子字串有出現在`wordDict`中，就代表這個長度為`n`的子字串符合條件，因此將LUT標記為`true`，之後就可以重複使用這個結果而不會重複檢查。

整個做法就是使用一個長度為`n-1`的布林陣列來紀錄各種長度的子字串是否符合條件，我們從長度為`1`到長度為`n`的子字串開始檢查。我們在檢查每個長度的子字串時，都去將這個子字串拆成左右兩部分，我們去檢查左半邊是否符合條件，如果符合條件的話再去檢查右半邊是否存在於`wordDict`中，其中檢查左半邊是否符合條件可以使用一開始建立的布林陣列。由於整體程式包含兩個回圈而回圈中的`substr()`的時間複雜度為`O(n)`，因此整體時間複雜度為`O(n^3)`。

```cpp
class Solution {
public:
    bool wordBreak(string s, vector<string>& wordDict) {
        unordered_set<string> word_set(wordDict.begin(), wordDict.end());
        vector<bool> dp(s.length() + 1);
        dp[0] = true;

        for (int i = 1; i <= s.length(); i++) {
            for (int j = 0; j < i; j++) {
                string sstr = s.substr(j, i - j);
                if (dp[j] and
                    word_set.find(sstr) != word_set.end()) {
                    dp[i] = true;
                    break;
                }
            }
        }
        return dp[s.length()];
    }
};
```

<img width="608" alt="圖片" src="https://user-images.githubusercontent.com/55487740/158116902-c9c7ca5d-6f77-4d2c-81dd-ab81901c1701.png">
