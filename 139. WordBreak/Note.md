# Note

## Baseline Solution

這個解法會對應到LeetCode中的暴力解，作法為：一開始先使用`unordered_map`來記錄所有`wordDict`中的變數，這樣我們就可以讓我們在`O(1)`的時間內找到`wordDict`中是否存在我們要找的字串。另外，我們還使用另外一個函數來作為執行遞迴功能，該函數中會從頭開始一個一個將字元加入子字串中，之後去檢查該子字串是否出現在`wordDict`中，如果有的話就遞迴呼叫相同函數來檢查剩下的子字串是否歐虧；反之，如果沒有的話，就再繼續檢查；若已經將所有字元加入子字串中還找不到，就代表這個子字串不歐虧，因此回傳`false`。

使用這個方法在LeetCode中會跑不過，運算時間過長。他的時間複雜度在最差的情況為`O(2^n)`，原因是假如我們每次在將新的字元加進來子字串時`wordDict`中都有一個符合的字串，他就會去遞迴搜尋剩下的子字串是否歐虧。一開始我一直想不到為什麼時間複雜度是`O(2^n)`而不是`O(n!)`，我會覺得是`O(n!)`的原因是想說對於一個長度為`n`的字串，他在遞迴中的第一層時一共需要呼叫`n-1`次第二層的遞迴函數，然後第二層的遞迴函數則需要呼叫`n-1`次第三層的遞迴函數......。不過其實第二層的遞迴函數並不是每個都會呼叫`n-2`次第三層的遞迴函數，原因是：這`n-1`個第二層的遞迴函數對應到的子字串長度其實不同，只有一個人的長度是`n-1`，最短的甚至為`1`。基於這個原因我們可以了解到第一層一共會呼叫`n-1`個第二層的遞迴函數，所有第二層的遞迴函數「一共」會呼叫`(n-3)+(n-4)+...+1`個第三層的遞迴函數（如果只看當前三層就可以知道總次數不會是`n*(n-1)*(n-2)`）。下圖為網路上別人畫的圖，圖片的看法為：線上的字代表該子字串有出現在`wordDict`中，而每個節點代表呼叫遞迴函數來檢查剩下的子字串。透過這張圖可以清楚地了解一個長的為4的字串一共會呼叫`8`次遞迴函數（灰色部分會被返回，不會被走到），因此可以總結出一共需要`2^(n-1)`的時間來完成此程式，時間複雜度為`2^n`。

![圖片](https://user-images.githubusercontent.com/55487740/158069856-18153158-c159-413a-ba9b-fb823de76124.png)

## Recursion with memoization

原本的作法運作起來非常慢的一個原因是他會重複檢查相同的子字串，其中每一次檢查都需要花很多時間。為了改善這個問題，其實可以使用之前用過的**Recursion with memoization**方法，將已經檢查過的資料以一個變數來記憶，這題因為丟入遞迴函數的是字串變數，回傳的是布林變數，因此記憶體變數會採用以字串作為key、以布林作為value的`unordered_map`。

使用這個方法的時間複雜度為`O(n^3)`，原因是遞迴數中一共有`n^2`個節點，其中每個節點都有使用時間複雜度為`O(n)`的函數`substr()`。

<img width="725" alt="圖片" src="https://user-images.githubusercontent.com/55487740/158025377-5f3de77e-c8de-4795-b2c9-14f64c938c4e.png">

## DP Solution

DP就是使用已經解決的小問題來解決大問題，這題其實也可以拆解成這樣的作法。我們每次檢查一個字串是否符合條件都會去檢查（1）子字串是否出現在`wordDict`中、（2）剩下的子字串是否符合條件。這當中比較需要調整的其實只有（2），然而我們在檢查這個條件的時候，常常都會搜尋到重複的，為了避免搜尋到重複的，我們使用DP的方式來記錄目前遇到的子字串是否符合條件。
